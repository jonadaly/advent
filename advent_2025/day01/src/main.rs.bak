use std::fs;

fn rotate(start: i32, count: i32) -> (i32, i32) {
    // Calculate final position (handle negative wrapping)
    let position = ((start + count) % 100 + 100) % 100;

    // Count how many times we cross 0 during rotation
    let clicks = if count > 0 {
        // Moving right: every time we pass through a multiple of 100, we hit 0
        (start + count) / 100 - start / 100
    } else if count < 0 {
        // Moving left: count how many times we wrap from 0 to 99
        let steps = -count;
        if start == 0 {
            // Starting at 0, we only hit 0 again after complete cycles
            steps / 100
        } else if steps >= start {
            // We cross 0 at least once (including when we land exactly on 0)
            // After 'start' steps we hit 0, then every 100 steps after that
            1 + (steps - start) / 100
        } else {
            // We don't reach 0
            0
        }
    } else {
        0
    };

    (position, clicks)
}

fn main() {
    let contents = fs::read_to_string("example.txt").expect("Could not read file");
    let instructions = contents
        .lines()
        .map(|x| (x.chars().nth(0).unwrap(), x[1..].parse::<i32>().unwrap()))
        .collect::<Vec<_>>();

    let mut current = 50;
    let mut part2_count = 0;
    for (direction, amount) in instructions {
        let rotation = match direction {
            'R' => amount,
            'L' => -amount,
            _ => panic!("Invalid direction"),
        };
        let (position, clicks) = rotate(current, rotation);
        part2_count += clicks;
        current = position;
    }
    println!("Part 2: {}", part2_count);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rotate() {
        assert_eq!(rotate(50, -68), (82, 1));
        assert_eq!(rotate(82, -30), (52, 0));
        assert_eq!(rotate(52, 48), (0, 1));
        assert_eq!(rotate(0, -5), (95, 0));
        assert_eq!(rotate(95, 60), (55, 1));
        assert_eq!(rotate(55, -55), (0, 1));
        assert_eq!(rotate(0, -1), (99, 0));
        assert_eq!(rotate(99, -99), (0, 1));
        assert_eq!(rotate(0, 14), (14, 0));
        assert_eq!(rotate(14, -82), (32, 1));

        // Additional test cases
        assert_eq!(rotate(50, 1000), (50, 10)); // From problem description
        assert_eq!(rotate(0, 100), (0, 1)); // Full rotation starting at 0
        assert_eq!(rotate(0, 200), (0, 2)); // Two full rotations starting at 0
        assert_eq!(rotate(50, -150), (0, 2)); // Should cross 0 twice going left
    }
}
